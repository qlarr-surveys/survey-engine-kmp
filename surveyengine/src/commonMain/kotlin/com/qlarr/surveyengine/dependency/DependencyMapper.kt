package com.qlarr.surveyengine.dependency

import com.qlarr.surveyengine.context.assemble.commonParent
import com.qlarr.surveyengine.model.*
import com.qlarr.surveyengine.model.ReservedCode.*


internal class DependencyMapper {
    val impactMap: ImpactMap get() = mutableImpactMap
    val dependencyMap: DependencyMap get() = mutableDependencyMap
    val correctedInstructions: Map<Dependency, String> get() = mutableCorrectedInstructions

    private val mutableImpactMap: MutableImpactMap = mutableMapOf()
    private val mutableDependencyMap: MutableDependencyMap = mutableMapOf()
    private val mutableCorrectedInstructions: MutableMap<Dependency, String> = mutableMapOf()

    constructor(stringImpactMap: StringImpactMap) {
        mutableImpactMap.putAll(stringImpactMap.toImpactMap())
        mutableDependencyMap.putAll(impactMap.toDependencyMap())
    }

    constructor(qualifiedComponents: List<ChildlessComponent>, correctCyclicalRelevance: Boolean = false) {
        mutableDependencyMap.putAll(resolveDependencyMap(qualifiedComponents, correctCyclicalRelevance))
        mutableImpactMap.putAll(dependencyMap.toImpactMap())
    }

    private fun resolveDependencyMap(
        qualifiedComponents: List<ChildlessComponent>,
        correctCyclicalRelevance: Boolean
    ): DependencyMap {
        val dependentsMap = hashMapOf<Dependent, List<Dependency>>()
        qualifiedComponents.forEach { component ->
            component
                .instructionList
                .filter { it is Instruction.State && it.isActive || it is Instruction.Reference }
                .forEach { instruction ->
                    val text = (instruction as? Instruction.State)?.text
                        ?: (instruction as Instruction.Reference).text()
                    val dependencyList = getDependencyList(qualifiedComponents, text)
                    if (correctCyclicalRelevance) {
                        val cleanedUpDependencies: List<Dependency> =
                            if (component.code != "Survey" &&
                                instruction is Instruction.State &&
                                instruction.code !in autoGeneratedDependencies
                            ) {
                                dependencyList.fixCyclicalRelevance(
                                    component,
                                    instruction,
                                    qualifiedComponents,
                                    dependentsMap
                                )
                            } else {
                                dependencyList
                            }
                        if (cleanedUpDependencies.isNotEmpty()) {
                            dependentsMap[Dependent(component.code, instruction.code)] = cleanedUpDependencies
                        }
                    } else {
                        if (dependencyList.isNotEmpty()) {
                            dependentsMap[Dependent(component.code, instruction.code)] = dependencyList
                        }
                    }

                }
        }
        return dependentsMap
    }

    private fun List<Dependency>.fixCyclicalRelevance(
        component: ChildlessComponent,
        instruction: Instruction.State,
        qualifiedComponents: List<ChildlessComponent>,
        dependentsMap: DependencyMap,
    ): List<Dependency> {
        val instructionToBeCorrected = Dependency(component.code, instruction.reservedCode)
        var instructionText = instruction.text
        val returnList = mutableListOf<Dependency>()
        forEach { dependency ->
            // if I am dependent on a relevance instruction
            if (dependency.reservedCode == Relevance && dependency.componentCode != component.code) {
                val commonParent =
                    qualifiedComponents.commonParent(component.code, dependency.componentCode)
                // our common parent has a child relevance instruction
                if (commonParent?.instructionList?.any { it.code == ChildrenRelevance.code } == true) {
                    // Then we are in trouble, i depend on my sibling, which depends on my parent which depends on us
                    // But now I will break my siblings relevance and consume directly its dependencies, excluding
                    // the parent dependency, because mine is dependent on it anyways
                    val replacementList = spreadCyclicalRelevance(dependentsMap, commonParent.code, listOf(dependency))
                    instructionText = instructionText.replace(
                        oldValue = dependency.asCode(),
                        newValue = replacementList.joinToString(separator = " && ", transform = { it.asCode() })
                    )
                    mutableCorrectedInstructions[instructionToBeCorrected] = instructionText
                    returnList.addAll(replacementList)
                } else {
                    returnList.add(dependency)
                }
            } else {
                returnList.add(dependency)
            }

        }
        return returnList
    }

    private fun spreadCyclicalRelevance(
        dependencyMap: DependencyMap,
        codeToIgnore: String,
        dependencies: List<Dependency>
    ): List<Dependency> {
        val returnList = mutableListOf<Dependency>()
        dependencies.forEach { dependency ->
            if (dependency.reservedCode != Relevance) {
                returnList.add(dependency)
            } else if (dependency.componentCode != codeToIgnore) {
                dependencyMap[dependency.toDependent()]?.let {
                    returnList.addAll(spreadCyclicalRelevance(dependencyMap, codeToIgnore, it))
                }
            }
        }
        return returnList
    }

    private fun getDependencyList(
        qualifiedComponents: List<ChildlessComponent>,
        instructionText: String
    ): List<Dependency> {
        val impactedList = mutableListOf<Dependency>()
        qualifiedComponents.forEach { component ->
            if (instructionText.contains(component.code)) {
                impactedList.addAll(component.getDependencies().filter { instructionText.contains(it.asCode()) })
            }
        }
        return impactedList
    }
}

fun ImpactMap.toDependencyMap(): DependencyMap {
    val dependentsMap: MutableDependencyMap = hashMapOf()
    forEach { entry ->
        dependentsMap.insertDependency(entry.key, entry.value)
    }
    return dependentsMap
}

fun DependencyMap.toImpactMap(): ImpactMap {
    val impactMap: MutableImpactMap = hashMapOf()
    forEach { entry ->
        impactMap.insertDependent(entry.key, entry.value)
    }
    return impactMap
}

private fun MutableDependencyMap.insertDependency(
    dependency: Dependency,
    dependents: List<Dependent>
) {
    dependents.forEach { dependent ->
        if (keys.contains(dependent)) {
            val list = get(dependent)!!
            if (!list.contains(dependency)) {
                put(dependent, list.toMutableList().apply { add(dependency) })
            }
        } else {
            put(dependent, listOf(dependency))
        }
    }
}

private fun MutableImpactMap.insertDependent(
    dependent: Dependent,
    dependencies: List<Dependency>
) {
    dependencies.forEach { dependency ->
        if (keys.contains(dependency)) {
            val list = get(dependency)!!
            if (!list.contains(dependent)) {
                put(dependency, list.toMutableList().apply { add(dependent) })
            }
        } else {
            put(dependency, listOf(dependent))
        }
    }
}


fun Dependency.toDependent() = Dependent(componentCode, reservedCode.code)
private fun List<Dependency>.stringify() = joinToString { "${it.componentCode}.${it.reservedCode.code}" }

// those are potential dependents on relevance, that are auto generated by this lib
private val autoGeneratedDependencies = listOf(
    Relevance.code,
    Validity.code,
    ChildrenRelevance.code
)

data class CyclicCorrection(
    val toReplace: Dependency,
    val replacement: List<Dependency>
)
